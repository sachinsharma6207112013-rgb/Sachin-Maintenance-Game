<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Parkour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .screen {
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 16px;
            border: 2px solid #00f3ff;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            pointer-events: auto;
            display: none;
            animation: fadeIn 0.3s ease;
            max-width: 400px;
            width: 90%;
        }

        .screen.active {
            display: block;
        }

        h1 {
            margin: 0 0 20px;
            font-size: 3rem;
            color: #00f3ff;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-shadow: 2px 2px 0px #fff;
        }

        p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 30px;
            text-align: left;
            font-size: 0.9rem;
            color: #ddd;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
        }

        button {
            background: #00f3ff;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            text-transform: uppercase;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.6);
        }

        button:active {
            transform: scale(0.95);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            pointer-events: none;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .touch-btn {
            pointer-events: auto;
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            touch-action: manipulation;
            user-select: none;
        }

        .touch-btn:active {
            background: rgba(0, 243, 255, 0.3);
        }

        .d-pad {
            display: flex;
            gap: 20px;
        }

        @media (max-width: 768px) {
            #mobile-controls { display: flex; }
            h1 { font-size: 2rem; }
            .screen { padding: 20px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="start-screen" class="screen active">
            <h1>Neon Parkour</h1>
            <div class="controls">
                <div>Move</div><div><strong>A / D</strong> or Arrows</div>
                <div>Jump</div><div><strong>Space</strong> / W</div>
                <div>Wall Jump</div><div><strong>Jump</strong> on wall</div>
                <div>Restart</div><div><strong>R</strong></div>
            </div>
            <button onclick="game.start()">Play</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h1 style="color: #ff4444; text-shadow: 2px 2px 0 #fff;">Wasted</h1>
            <p>You hit a hazard or fell into the void.</p>
            <button onclick="game.reset()">Try Again</button>
        </div>

        <div id="win-screen" class="screen">
            <h1 style="color: #44ff44;">Course Clear!</h1>
            <p id="win-time">Time: 0s</p>
            <button onclick="game.reset()">Play Again</button>
        </div>
    </div>

    <div id="hud">Time: 0.0s</div>

    <div id="mobile-controls">
        <div class="d-pad">
            <div class="touch-btn" id="btn-left">←</div>
            <div class="touch-btn" id="btn-right">→</div>
        </div>
        <div class="touch-btn" id="btn-jump">↑</div>
    </div>

<script>


const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRAVITY = 0.6;
const FRICTION = 0.85;
const MOVE_SPEED = 0.8;
const MAX_SPEED = 9;
const JUMP_FORCE = 13;
const WALL_SLIDE_SPEED = 2;
const WALL_JUMP_FORCE_X = 10;
const WALL_JUMP_FORCE_Y = 14;


const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    w: false, a: false, s: false, d: false, " ": false
};

window.addEventListener('keydown', (e) => {
    if(keys.hasOwnProperty(e.key) || e.key === " ") keys[e.key] = true;
    if(e.key === 'r' || e.key === 'R') game.reset();
});

window.addEventListener('keyup', (e) => {
    if(keys.hasOwnProperty(e.key) || e.key === " ") keys[e.key] = false;
});


const setupTouch = (id, keyMocks) => {
    const el = document.getElementById(id);
    el.addEventListener('touchstart', (e) => { e.preventDefault(); keyMocks.forEach(k => keys[k] = true); });
    el.addEventListener('touchend', (e) => { e.preventDefault(); keyMocks.forEach(k => keys[k] = false); });
};
setupTouch('btn-left', ['ArrowLeft', 'a']);
setupTouch('btn-right', ['ArrowRight', 'd']);
setupTouch('btn-jump', [' ', 'ArrowUp', 'w']);

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 4 + 2;
        this.speedX = Math.random() * 4 - 2;
        this.speedY = Math.random() * 4 - 2;
        this.color = color;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life -= this.decay;
        this.size *= 0.95;
    }

    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Player {
    constructor(x, y) {
        this.startPos = {x, y};
        this.x = x;
        this.y = y;
        this.width = 30;
        this.height = 30;
        this.vx = 0;
        this.vy = 0;
        this.isGrounded = false;
        this.canDoubleJump = false;
        this.isWallSliding = false;
        this.wallDir = 0; // -1 left, 1 right
        this.color = '#00f3ff';
        this.trail = [];
    }

    reset() {
        this.x = this.startPos.x;
        this.y = this.startPos.y;
        this.vx = 0;
        this.vy = 0;
        this.trail = [];
    }

    update(platforms, hazards, goal) {

        const left = keys.ArrowLeft || keys.a;
        const right = keys.ArrowRight || keys.d;
        const jump = keys.ArrowUp || keys.w || keys[" "];

  
        if (left) this.vx -= MOVE_SPEED;
        if (right) this.vx += MOVE_SPEED;

        this.vx *= FRICTION;
        

        if (this.vx > MAX_SPEED) this.vx = MAX_SPEED;
        if (this.vx < -MAX_SPEED) this.vx = -MAX_SPEED;


        this.vy += GRAVITY;


        this.x += this.vx;
        this.checkHorizontalCollisions(platforms);
        
        this.y += this.vy;
        this.checkVerticalCollisions(platforms);


        this.handleWallInteractions(left, right, jump);


        if (this.isGrounded && jump && !this.jumpLocked) {
            this.vy = -JUMP_FORCE;
            this.isGrounded = false;
            this.canDoubleJump = true;
            this.jumpLocked = true;
            game.createParticles(this.x + this.width/2, this.y + this.height, '#fff', 10);
        } 

        else if (!this.isGrounded && !this.isWallSliding && this.canDoubleJump && jump && !this.jumpLocked) {
            this.vy = -JUMP_FORCE * 0.8;
            this.canDoubleJump = false;
            this.jumpLocked = true;
            game.createParticles(this.x + this.width/2, this.y + this.height, '#00f3ff', 8);
        }

        if (!jump) this.jumpLocked = false;


        for (let h of hazards) {
            if (this.checkOverlap(h)) {
                game.gameOver();
                return;
            }
        }


        if (this.checkOverlap(goal)) {
            game.win();
            return;
        }


        if (this.y > 2000) {
            game.gameOver();
        }


        if (Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1) {
            this.trail.push({x: this.x, y: this.y, alpha: 0.6});
        }
        if (this.trail.length > 10) this.trail.shift();
    }

    handleWallInteractions(left, right, jump) {
        this.isWallSliding = false;
        

        if (!this.isGrounded && this.vy > 0) {

             let touchingLeft = false;
             let touchingRight = false;
             

             for(let p of game.level.platforms) {
                if(this.y + this.height > p.y && this.y < p.y + p.height) {
                                    
                    if (this.x <= p.x + p.width + 1 && this.x >= p.x + p.width - 5) touchingLeft = true;

                    if (this.x + this.width >= p.x - 1 && this.x + this.width <= p.x + 5) touchingRight = true;
                }
             }

             if (touchingLeft && left) {
                 this.isWallSliding = true;
                 this.wallDir = -1;
             } else if (touchingRight && right) {
                 this.isWallSliding = true;
                 this.wallDir = 1;
             }

             if (this.isWallSliding) {
                 if (this.vy > WALL_SLIDE_SPEED) this.vy = WALL_SLIDE_SPEED;
                 
                 if (jump && !this.jumpLocked) {
                     this.vy = -WALL_JUMP_FORCE_Y;
                     this.vx = -this.wallDir * WALL_JUMP_FORCE_X;
                     this.jumpLocked = true;
                     this.isWallSliding = false;
                     this.canDoubleJump = true;
                     game.createParticles(
                         this.wallDir === 1 ? this.x + this.width : this.x, 
                         this.y + this.height/2, 
                         '#fff', 10
                    );
                 }
             }
        }
    }

    checkHorizontalCollisions(platforms) {
        for (let p of platforms) {
            if (this.checkOverlap(p)) {
              
                if (this.vx > 0) {
                    this.x = p.x - this.width;
                }
             
                else if (this.vx < 0) {
                    this.x = p.x + p.width;
                }
                this.vx = 0;
            }
        }
    }

    checkVerticalCollisions(platforms) {
        this.isGrounded = false;
        for (let p of platforms) {
            if (this.checkOverlap(p)) {
              
                if (this.vy > 0) {
                    this.y = p.y - this.height;
                    this.isGrounded = true;
                    this.canDoubleJump = true;
                    this.vy = 0;
                }
              
                else if (this.vy < 0) {
                    this.y = p.y + p.height;
                    this.vy = 0;
                }
            }
        }
    }

    checkOverlap(rect) {
        return (this.x < rect.x + rect.width &&
                this.x + this.width > rect.x &&
                this.y < rect.y + rect.height &&
                this.y + this.height > rect.y);
    }

    draw(ctx, camX, camY) {
      
        this.trail.forEach((t, i) => {
            t.alpha -= 0.05;
            ctx.fillStyle = `rgba(0, 243, 255, ${t.alpha})`;
            ctx.fillRect(t.x - camX, t.y - camY, this.width, this.height);
        });
        this.trail = this.trail.filter(t => t.alpha > 0);

     
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, this.width, this.height);
        ctx.shadowBlur = 0;

      
        ctx.fillStyle = 'black';
        let eyeOffset = this.vx >= 0 ? 20 : 5;
        if (Math.abs(this.vx) < 0.1) eyeOffset = 20;
        ctx.fillRect(this.x - camX + eyeOffset, this.y - camY + 8, 5, 5);
    }
}

class Game {
    constructor() {
        this.state = 'start'; 
        this.player = new Player(100, 300);
        this.level = this.generateLevel();
        this.particles = [];
        this.camera = { x: 0, y: 0 };
        this.startTime = 0;
        this.elapsedTime = 0;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    generateLevel() {
      
        const data = [
           
            {t:0, x: 0, y: 400, w: 800, h: 50}, 
            {t:0, x: -50, y: 0, w: 50, h: 1000},

           
            {t:0, x: 900, y: 350, w: 200, h: 20},
            {t:0, x: 1200, y: 300, w: 100, h: 20},
            
           
            {t:0, x: 1400, y: 100, w: 50, h: 400},
            {t:0, x: 1650, y: -100, w: 50, h: 400},
            
           
            {t:1, x: 1800, y: 500, w: 800, h: 50},
            {t:0, x: 1900, y: 200, w: 100, h: 20},
            {t:0, x: 2200, y: 200, w: 100, h: 20},
            
           
            {t:0, x: 2500, y: 400, w: 300, h: 50},
            {t:0, x: 2800, y: 200, w: 30, h: 300},
            {t:0, x: 2600, y: 0, w: 30, h: 200},
            {t:0, x: 2900, y: -150, w: 100, h: 20},

            
            {t:1, x: 3000, y: 400, w: 1000, h: 50},
            {t:0, x: 3200, y: 0, w: 50, h: 20},
            {t:0, x: 3500, y: 100, w: 50, h: 20},
            {t:0, x: 3800, y: 200, w: 50, h: 20},

           
            {t:0, x: 4100, y: 300, w: 400, h: 50},
            {t:1, x: 4250, y: 290, w: 50, h: 10},
            
           
            {t:2, x: 4400, y: 200, w: 50, h: 100}
        ];

        const platforms = [];
        const hazards = [];
        let goal = {};

        data.forEach(o => {
            if (o.t === 0) platforms.push({x: o.x, y: o.y, width: o.w, height: o.h});
            if (o.t === 1) hazards.push({x: o.x, y: o.y, width: o.w, height: o.h});
            if (o.t === 2) goal = {x: o.x, y: o.y, width: o.w, height: o.h};
        });

        return { platforms, hazards, goal };
    }

    start() {
        this.state = 'playing';
        this.player.reset();
        this.startTime = Date.now();
        this.elapsedTime = 0;
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    }

    reset() {
        this.state = 'playing';
        this.player.reset();
        this.startTime = Date.now();
        this.particles = [];
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    }

    gameOver() {
        this.state = 'gameover';
        document.getElementById('game-over-screen').classList.add('active');
    }

    win() {
        this.state = 'win';
        document.getElementById('win-screen').classList.add('active');
        document.getElementById('win-time').innerText = `Time: ${(this.elapsedTime/1000).toFixed(2)}s`;
    }

    createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    update() {
        if (this.state !== 'playing') return;

        this.elapsedTime = Date.now() - this.startTime;
        document.getElementById('hud').innerText = `Time: ${(this.elapsedTime/1000).toFixed(1)}s`;

        this.player.update(this.level.platforms, this.level.hazards, this.level.goal);

        let targetCamX = this.player.x + this.player.width/2 - canvas.width/2;
        let targetCamY = this.player.y + this.player.height/2 - canvas.height/2;
        
        this.camera.x += (targetCamX - this.camera.x) * 0.1;
        this.camera.y += (targetCamY - this.camera.y) * 0.1;

        if(this.camera.y > 200) this.camera.y = 200;

        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => p.life > 0);
    }

    draw() {
     
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#222';
        ctx.lineWidth = 2;
        const gridSize = 100;
        const offX = Math.floor(this.camera.x * 0.5) % gridSize;
        const offY = Math.floor(this.camera.y * 0.5) % gridSize;
        
        ctx.beginPath();
        for(let x = -offX; x < canvas.width; x+=gridSize) {
            ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height);
        }
        for(let y = -offY; y < canvas.height; y+=gridSize) {
            ctx.moveTo(0, y); ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();


        ctx.fillStyle = '#eee';
        for(let p of this.level.platforms) {
         
            if(p.x - this.camera.x + p.width > 0 && p.x - this.camera.x < canvas.width &&
               p.y - this.camera.y + p.height > 0 && p.y - this.camera.y < canvas.height) {
                ctx.fillRect(p.x - this.camera.x, p.y - this.camera.y, p.width, p.height);
               
                ctx.strokeStyle = '#555';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x - this.camera.x, p.y - this.camera.y, p.width, p.height);
            }
        }

        ctx.fillStyle = '#ff3333';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ff0000';
        for(let h of this.level.hazards) {
             if(h.x - this.camera.x + h.width > 0 && h.x - this.camera.x < canvas.width) {
                ctx.fillRect(h.x - this.camera.x, h.y - this.camera.y, h.width, h.height);
             }
        }
        ctx.shadowBlur = 0;

        const g = this.level.goal;
        ctx.fillStyle = '#33ff33';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00ff00';
        ctx.fillRect(g.x - this.camera.x, g.y - this.camera.y, g.width, g.height);
        ctx.shadowBlur = 0;

        for(let p of this.particles) {
            p.draw(ctx, this.camera.x, this.camera.y);
        }

        if (this.state === 'playing') {
            this.player.draw(ctx, this.camera.x, this.camera.y);
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

const game = new Game();

</script>
</body>
</html>